<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gesture-Controlled Holographic Particles</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Courier New', Courier, monospace; }
        canvas { display: block; }
        #video-input { position: absolute; top: 0; left: 0; opacity: 0; pointer-events: none; z-index: -1; }
        #ui-layer {
            position: absolute; top: 20px; left: 20px; color: #00ffcc;
            text-shadow: 0 0 10px #00ffcc; pointer-events: none;
        }
        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; font-size: 24px; text-align: center;
        }
        .hud-item { margin-bottom: 5px; font-size: 14px; background: rgba(0,0,0,0.5); padding: 5px; border-left: 2px solid #00ffcc; }
        #cam-preview {
            position: absolute; bottom: 20px; right: 20px; width: 160px; height: 120px;
            border: 1px solid #333; transform: scaleX(-1); opacity: 0.7;
        }
    </style>
</head>
<body>

    <!-- UI & Loading -->
    <div id="loading">Initializing Neural Interface...<br><span style="font-size:14px; color:#888">(Allow Camera Access)</span></div>
    <div id="ui-layer">
        <div class="hud-item" id="status">System: Waiting for Hand...</div>
        <div class="hud-item" id="mode">Mode: NEBULA (Default)</div>
        <div class="hud-item">
            GESTURES:<br>
            • Open Palm: Expand<br>
            • Fist: Contract/Black Hole<br>
            • Pinch: High Density<br>
            • Swipe Left/Right: Switch Shape<br>
            • Two Hands: Supernova
        </div>
    </div>
    
    <!-- Hidden Video for Processing -->
    <video id="video-input" autoplay playsinline></video>
    <!-- Visual Feedback of tracking -->
    <canvas id="cam-preview"></canvas>

    <!-- Import Modules -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { FilesetResolver, HandLandmarker } from '@mediapipe/tasks-vision';

        // --- CONFIGURATION ---
        const PARTICLE_COUNT = 80000; // High performance count
        const MODES = ['NEBULA', 'HEART', 'FLOWER', 'SATURN', 'FIREWORKS'];
        
        // --- GLOBAL STATE ---
        const state = {
            handDetected: false,
            handPosition: new THREE.Vector3(0, 0, 0), // Normalized -1 to 1
            pinch: 0.0, // 0 to 1
            expansion: 0.0, // -1 (contract) to 1 (expand)
            modeIndex: 0,
            targetModeIndex: 0,
            rotationSpeed: 0.2,
            doubleHand: 0.0, // 0 or 1
            swipeCooldown: 0
        };

        // --- SHADERS ---

        const vertexShader = `
            uniform float uTime;
            uniform float uMode; // 0=Nebula, 1=Heart, 2=Flower, 3=Saturn, 4=Fireworks
            uniform float uPinch;
            uniform float uExpansion;
            uniform vec3 uHandPos;
            uniform float uDoubleHand;
            
            attribute float aRandom;
            attribute vec3 aRandomVec;
            
            varying vec3 vColor;
            varying float vAlpha;

            // --- SHAPE FUNCTIONS ---

            // 1. Heart Function
            vec3 getHeart(float t, float r) {
                float x = 16.0 * pow(sin(t), 3.0);
                float y = 13.0 * cos(t) - 5.0 * cos(2.0*t) - 2.0 * cos(3.0*t) - cos(4.0*t);
                float z = r * 10.0;
                return vec3(x, y, z) * 0.15;
            }

            // 2. Flower Function
            vec3 getFlower(float t, float r) {
                float petal = abs(cos(t * 3.0)) + 0.5;
                float rad = r * 5.0 * petal;
                return vec3(cos(t) * rad, sin(t) * rad, (r-0.5)*2.0);
            }

            // 3. Saturn Function
            vec3 getSaturn(float t, float r) {
                // Ring
                if (r > 0.4) {
                    float ringRad = 4.0 + (r * 2.0);
                    return vec3(cos(t) * ringRad, sin(t) * ringRad, (aRandom-0.5) * 0.2);
                } 
                // Planet
                else {
                    float phi = acos(2.0 * r - 1.0) - 1.57; // distribute vertically
                    float theta = t;
                    float rad = 2.0;
                    return vec3(rad * cos(theta) * cos(phi), rad * sin(theta) * cos(phi), rad * sin(phi));
                }
            }

            // 4. Fireworks / Burst
            vec3 getFireworks(vec3 basePos) {
                // Explode outwards based on random vector
                float burst = sin(uTime * 2.0 - aRandom * 10.0);
                return basePos + (aRandomVec * (burst > 0.8 ? burst * 5.0 : 0.0));
            }

            // 0. Abstract/Nebula (Noise driven)
            vec3 getNebula(vec3 base) {
                float noise = sin(base.x * 2.0 + uTime) * cos(base.y * 2.0 + uTime);
                return base * (1.0 + noise * 0.5);
            }

            // Helper to mix shapes smoothly
            vec3 lerp3(vec3 a, vec3 b, float w) {
                return mix(a, b, w);
            }

            void main() {
                // Basic parametric inputs
                float t = aRandom * 6.28318 * 2.0 + uTime * 0.1; // Angle
                float r = aRandomVec.x; // Radius variation
                
                // --- GEOMETRY CALCULATION ---
                
                // Base Sphere/Cloud for Nebula
                vec3 posNebula = aRandomVec * 5.0; 
                posNebula = getNebula(posNebula);

                vec3 posHeart = getHeart(t, r - 0.5);
                vec3 posFlower = getFlower(t, r);
                vec3 posSaturn = getSaturn(t, r);
                vec3 posFire = getFireworks(posSaturn); // Base fire on saturn ring logic initially

                // --- BLENDING MODES ---
                // We use smoothstep logic to mix based on uMode integer
                // This is a rough 4-way blend. Ideally handled via mix weights passed from JS, 
                // but doing it here allows "morphing" logic.
                
                vec3 finalPos = posNebula;
                
                // Smooth mixing logic (simple linear interpolation for demo)
                // 0->1
                if(uMode >= 0.0 && uMode < 1.0) finalPos = mix(posNebula, posHeart, uMode);
                // 1->2
                else if(uMode >= 1.0 && uMode < 2.0) finalPos = mix(posHeart, posFlower, uMode - 1.0);
                // 2->3
                else if(uMode >= 2.0 && uMode < 3.0) finalPos = mix(posFlower, posSaturn, uMode - 2.0);
                // 3->4
                else if(uMode >= 3.0 && uMode <= 4.0) finalPos = mix(posSaturn, posFire, uMode - 3.0);
                // Wrap 4->0 (not implemented strictly in cycle here, handled in JS)

                // --- GESTURE INTERACTION ---
                
                // 1. Expansion/Contraction (Palm Open/Close)
                // If uExpansion is high (open hand), particles fly out. 
                // If negative (fist), they suck in.
                float expandFactor = 1.0 + (uExpansion * 1.5); 
                finalPos *= expandFactor;

                // 2. Attraction/Repulsion to Hand
                // Convert handPos (screen space ish) to world roughly
                vec3 handWorld = uHandPos * 10.0; 
                float dist = distance(finalPos, handWorld);
                
                // Repulse if hand is close
                if (dist < 3.0) {
                    vec3 dir = normalize(finalPos - handWorld);
                    finalPos += dir * (3.0 - dist) * 2.0;
                }

                // 3. Pinch Effect (Density / Jitter)
                if (uPinch > 0.5) {
                    finalPos += aRandomVec * uPinch * 0.5; // Jitter
                }

                // 4. Double Hand Supernova
                if (uDoubleHand > 0.5) {
                    finalPos *= 1.0 + sin(uTime * 10.0) * 0.2; // Vibration
                    finalPos += aRandomVec * 5.0 * uDoubleHand; // Explosion
                }

                // 5. Rotation
                float c = cos(uTime * 0.2);
                float s = sin(uTime * 0.2);
                mat2 rot = mat2(c, -s, s, c);
                finalPos.xz = rot * finalPos.xz;

                vec4 mvPosition = modelViewMatrix * vec4(finalPos, 1.0);
                gl_Position = projectionMatrix * mvPosition;

                // --- SIZE & COLOR ---
                gl_PointSize = (4.0 * (1.0 + uPinch * 5.0) + (uDoubleHand * 10.0)) * (1.0 / -mvPosition.z);
                
                // Color logic
                vec3 colorBase = vec3(0.1, 0.4, 1.0); // Blueish
                vec3 colorHot = vec3(1.0, 0.2, 0.5);  // Reddish
                
                float mixVal = smoothstep(-2.0, 2.0, sin(uTime + finalPos.x));
                
                // Change color based on mode
                if(uMode > 0.5 && uMode < 1.5) colorBase = vec3(1.0, 0.05, 0.2); // Heart Red
                if(uMode > 1.5 && uMode < 2.5) colorBase = vec3(1.0, 0.8, 0.2); // Flower Gold
                if(uMode > 2.5 && uMode < 3.5) colorBase = vec3(0.5, 0.8, 1.0); // Saturn Cyan
                
                vColor = mix(colorBase, colorHot, aRandom);
                vColor += vec3(uPinch); // Whiten on pinch

                // Soft edges
                vAlpha = 1.0;
            }
        `;

        const fragmentShader = `
            varying vec3 vColor;
            varying float vAlpha;

            void main() {
                // Circular particle logic
                vec2 coord = gl_PointCoord - vec2(0.5);
                float dist = length(coord);
                
                // Soft glow
                float alpha = 1.0 - smoothstep(0.3, 0.5, dist);
                if (alpha < 0.01) discard;

                // Add inner core brightness
                vec3 finalColor = vColor + (0.5 * (1.0 - dist));

                gl_FragColor = vec4(finalColor, alpha * vAlpha);
            }
        `;

        // --- THREE.JS SETUP ---
        const scene = new THREE.Scene();
        // Fog for depth
        scene.fog = new THREE.FogExp2(0x000000, 0.02);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 20;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setClearColor(0x000000);
        document.body.appendChild(renderer.domElement);

        // --- PARTICLE SYSTEM ---
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(PARTICLE_COUNT * 3);
        const randoms = new Float32Array(PARTICLE_COUNT);
        const randomVecs = new Float32Array(PARTICLE_COUNT * 3);

        for (let i = 0; i < PARTICLE_COUNT; i++) {
            positions[i * 3] = 0;
            positions[i * 3 + 1] = 0;
            positions[i * 3 + 2] = 0;

            randoms[i] = Math.random();
            
            // Random sphere vector
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            randomVecs[i * 3] = Math.sin(phi) * Math.cos(theta);
            randomVecs[i * 3 + 1] = Math.sin(phi) * Math.sin(theta);
            randomVecs[i * 3 + 2] = Math.cos(phi);
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('aRandom', new THREE.BufferAttribute(randoms, 1));
        geometry.setAttribute('aRandomVec', new THREE.BufferAttribute(randomVecs, 3));

        const material = new THREE.ShaderMaterial({
            vertexShader,
            fragmentShader,
            uniforms: {
                uTime: { value: 0 },
                uMode: { value: 0 },
                uHandPos: { value: new THREE.Vector3(0, 0, 0) },
                uExpansion: { value: 0 },
                uPinch: { value: 0 },
                uDoubleHand: { value: 0 }
            },
            transparent: true,
            depthWrite: false,
            blending: THREE.AdditiveBlending
        });

        const particles = new THREE.Points(geometry, material);
        scene.add(particles);

        // --- MEDIAPIPE SETUP ---
        const video = document.getElementById('video-input');
        const previewCanvas = document.getElementById('cam-preview');
        const previewCtx = previewCanvas.getContext('2d');
        let handLandmarker;
        let lastVideoTime = -1;

        async function initMediaPipe() {
            const vision = await FilesetResolver.forVisionTasks(
                "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm"
            );
            handLandmarker = await HandLandmarker.createFromOptions(vision, {
                baseOptions: {
                    modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`,
                    delegate: "GPU"
                },
                runningMode: "VIDEO",
                numHands: 2
            });
            startCamera();
        }

        async function startCamera() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ video: true });
                video.srcObject = stream;
                video.addEventListener("loadeddata", () => {
                    document.getElementById('loading').style.display = 'none';
                    animate();
                });
            } catch (err) {
                document.getElementById('loading').innerHTML = "Camera Access Denied.<br>Reload and allow camera.";
                console.error(err);
            }
        }

        // --- GESTURE LOGIC ---
        function processGestures(results) {
            const landmarks = results.landmarks;
            state.handDetected = landmarks.length > 0;
            state.doubleHand = landmarks.length > 1 ? 1.0 : 0.0;

            document.getElementById('status').innerText = state.handDetected 
                ? `System: Tracking ${landmarks.length} Hand(s)` 
                : "System: Waiting for Hand...";

            if (state.handDetected) {
                const hand1 = landmarks[0];
                
                // 1. Hand Position (Average of Wrist + Middle Finger Tip)
                // Invert X because webcam is mirrored logic vs 3D space
                const x = (hand1[0].x + hand1[9].x) / 2; 
                const y = (hand1[0].y + hand1[9].y) / 2;
                
                // Map 0..1 to -1..1
                const nx = (x - 0.5) * 2; 
                const ny = -(y - 0.5) * 2; // Flip Y for 3D
                
                // Smooth damping
                state.handPosition.x += (nx - state.handPosition.x) * 0.1;
                state.handPosition.y += (ny - state.handPosition.y) * 0.1;

                // 2. Pinch (Distance between Thumb Tip [4] and Index Tip [8])
                const pinchDist = Math.hypot(hand1[4].x - hand1[8].x, hand1[4].y - hand1[8].y);
                const isPinch = pinchDist < 0.05;
                state.pinch += ((isPinch ? 1.0 : 0.0) - state.pinch) * 0.1;

                // 3. Open vs Closed (Average distance of tips from wrist)
                const tips = [8, 12, 16, 20];
                let avgTipDist = 0;
                tips.forEach(i => {
                    avgTipDist += Math.hypot(hand1[i].x - hand1[0].x, hand1[i].y - hand1[0].y);
                });
                avgTipDist /= 4;
                
                // Calibrate: < 0.2 is Fist, > 0.4 is Open
                let targetExpand = 0;
                if(avgTipDist > 0.35) targetExpand = 1.0; // Open
                else if(avgTipDist < 0.25) targetExpand = -1.0; // Fist (Black hole)
                
                state.expansion += (targetExpand - state.expansion) * 0.05;

                // 4. Swipe Detection for Mode Switch
                // Simple logic: if hand moves fast in X while open
                if (state.swipeCooldown <= 0 && Math.abs(state.handPosition.x) > 0.6) {
                     // Check velocity roughly by comparing to last frame (simplified here by position threshold)
                     // A real swipe needs velocity, but position edge trigger works for simple demo
                     /* For robustness, let's just cycle if they hold at edge */
                }
                
                // Let's implement a cleaner Swipe:
                // If velocity X is high. We need previous X.
                // Storing previous X in a closure or global
                if (!state.lastX) state.lastX = nx;
                const dx = nx - state.lastX;
                state.lastX = nx;
                
                if (Math.abs(dx) > 0.15 && state.swipeCooldown <= 0) {
                    // Swipe detected
                    if (dx > 0) state.targetModeIndex = (state.targetModeIndex + 1) % MODES.length;
                    else state.targetModeIndex = (state.targetModeIndex - 1 + MODES.length) % MODES.length;
                    
                    state.swipeCooldown = 30; // Frames
                    
                    // Visual feedback
                    document.getElementById('mode').style.color = '#fff';
                    setTimeout(() => document.getElementById('mode').style.color = '#00ffcc', 200);
                }
            } else {
                // Reset to idle
                state.expansion += (0 - state.expansion) * 0.05;
                state.pinch += (0 - state.pinch) * 0.1;
            }

            if(state.swipeCooldown > 0) state.swipeCooldown--;
            
            // Update Mode UI
            document.getElementById('mode').innerText = `Mode: ${MODES[state.targetModeIndex]}`;
            
            // Smoothly interpolate shader mode uniform
            // We just approach the integer value
            const diff = state.targetModeIndex - material.uniforms.uMode.value;
            if (Math.abs(diff) > 0.01) {
                material.uniforms.uMode.value += diff * 0.05;
            }
        }

        // --- MAIN LOOP ---
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);

            // 1. Process MediaPipe
            if (video.videoWidth > 0 && video.currentTime !== lastVideoTime) {
                lastVideoTime = video.currentTime;
                if (handLandmarker) {
                    const results = handLandmarker.detectForVideo(video, performance.now());
                    processGestures(results);
                    
                    // Draw Debug Preview
                    previewCanvas.width = video.videoWidth;
                    previewCanvas.height = video.videoHeight;
                    previewCtx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
                    if(results.landmarks) {
                        for (const landmarks of results.landmarks) {
                            for(const point of landmarks) {
                                previewCtx.beginPath();
                                previewCtx.arc(point.x * previewCanvas.width, point.y * previewCanvas.height, 5, 0, 2*Math.PI);
                                previewCtx.fillStyle = "#00ffcc";
                                previewCtx.fill();
                            }
                        }
                    }
                }
            }

            // 2. Update Uniforms
            material.uniforms.uTime.value = clock.getElapsedTime();
            material.uniforms.uHandPos.value.copy(state.handPosition);
            material.uniforms.uExpansion.value = state.expansion;
            material.uniforms.uPinch.value = state.pinch;
            
            // Double hand triggers "supernova" expansion in shader + color shift
            // Smooth blending for double hand
            const targetDouble = state.doubleHand;
            material.uniforms.uDoubleHand.value += (targetDouble - material.uniforms.uDoubleHand.value) * 0.1;

            // 3. Render
            // Gentle idle rotation
            particles.rotation.y += 0.001;
            
            // Hand control rotation (tilt)
            particles.rotation.x = state.handPosition.y * 0.2;
            particles.rotation.z = state.handPosition.x * 0.2;

            renderer.render(scene, camera);
        }

        // Resize Handler
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        initMediaPipe();

    </script>
</body>
</html>
