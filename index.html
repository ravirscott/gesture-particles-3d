<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive GLSL Particle System</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000000;
        }
        canvas {
            display: block;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #ffffff;
            font-family: monospace;
            pointer-events: none;
            z-index: 10;
            background: rgba(0, 0, 0, 0.5);
            padding: 5px;
        }
    </style>
    <!-- Three.js CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>
    <div id="info">System: <span id="mode">Wavy Cloud</span> | Particles: 80,000</div>

    <!-- VERTEX SHADER -->
    <script type="x-shader/x-vertex" id="vertexshader">
        uniform float time;
        uniform float currentTemplate;
        uniform vec3 mousePosition;
        uniform float globalScale;
        
        attribute float size;
        
        varying vec3 vColor;

        // Constants
        const float PI = 3.14159265359;

        // Helper: Rotate vector
        vec3 rotateY(vec3 v, float angle) {
            float c = cos(angle);
            float s = sin(angle);
            return vec3(v.x * c + v.z * s, v.y, -v.x * s + v.z * c);
        }

        // --- TEMPLATE LOGIC ---
        
        // 0. Wavy Cloud
        void templateCloud(vec3 p, float t, out vec3 pos, out vec3 col) {
            pos = p;
            pos.x += sin(t + p.y) * 0.5;
            pos.y += cos(t + p.x) * 0.5;
            // Dynamic Blue/Cyan
            col = vec3(0.0, 0.5 + 0.5 * sin(t * 0.8), 1.0);
        }

        // 1. Breathing Sphere
        void templateSphere(vec3 p, float t, out vec3 pos, out vec3 col) {
            vec3 normP = normalize(p);
            // Pulse factor
            float pulse = 1.0 + 0.3 * sin(t * 1.5);
            pos = normP * length(p) * pulse; // Keep relative distribution but pulse outward
            // Flatten slightly to form a shell if initial p was random cube, 
            // but prompt asks to scale normalized p. Let's force sphere shape:
            pos = normP * 3.0 * pulse; 
            
            // Pulsing Fire Color
            col = vec3(1.0, 0.2 + 0.5 * sin(t * 0.5), 0.0);
        }

        // 2. Fireworks Burst
        void templateFireworks(vec3 p, float t, out vec3 pos, out vec3 col) {
            float phase = fract(t * 0.2); // Slower cycle for visibility
            
            // Random direction based on initial position
            vec3 dir = normalize(p);
            
            if (phase < 0.1) {
                // Reset / Compression phase
                pos = dir * (phase * 10.0); // Gather center
            } else {
                // Explosion phase
                float expansion = (phase - 0.1) * 15.0; // Rapid expansion
                pos = dir * expansion;
            }
            
            // Random color based on position modulated by time
            col = vec3(
                abs(sin(p.x + t)),
                abs(cos(p.y + t)),
                abs(sin(p.z + t))
            );
        }

        // 3. 2D Heart Shape
        void templateHeart(vec3 p, float t, out vec3 pos, out vec3 col) {
            // Map initial Z to parameter t_heart (0 to 2PI)
            float t_heart = (p.z + 2.0) * PI; 
            
            float x = 16.0 * pow(sin(t_heart), 3.0);
            float y = 13.0 * cos(t_heart) - 5.0 * cos(2.0*t_heart) - 2.0 * cos(3.0*t_heart) - cos(4.0*t_heart);
            
            // Scale down to fit view
            pos = vec3(x * 0.1, y * 0.1, p.x * 0.5); // Use p.x for some depth thickness
            
            // Solid Pink/Magenta
            col = vec3(1.0, 0.2, 0.6);
        }

        // 4. Rotating Saturn Ring
        void templateSaturn(vec3 p, float t, out vec3 pos, out vec3 col) {
            // Toroidal Math
            // Use initial X, Y to define angle theta, phi
            float theta = p.x * PI;
            float phi = p.y * PI;
            float majorR = 3.0;
            float minorR = 0.5 + p.z * 0.2; // Variation in ring thickness
            
            float tx = (majorR + minorR * cos(theta)) * cos(phi);
            float ty = (majorR + minorR * cos(theta)) * sin(phi); // Actually Z in standard math, but Y here
            float tz = minorR * sin(theta);
            
            vec3 rawPos = vec3(tx, tz, ty); // Flattened ring
            
            // Rotation Matrix (Y axis rotation)
            pos = rotateY(rawPos, t * 0.5);
            
            // Icy Blue/White
            col = vec3(0.5, 0.8, 1.0);
        }

        vec3 calculatePosition(vec3 p, float t, float templateID, out vec3 colorResult) {
            vec3 finalPos = p;
            
            // In a production shader, mixing logic would be cleaner, 
            // but standard if/else works for strictly defined states.
            if (templateID < 0.5) {
                templateCloud(p, t, finalPos, colorResult);
            } else if (templateID < 1.5) {
                templateSphere(p, t, finalPos, colorResult);
            } else if (templateID < 2.5) {
                templateFireworks(p, t, finalPos, colorResult);
            } else if (templateID < 3.5) {
                templateHeart(p, t, finalPos, colorResult);
            } else {
                templateSaturn(p, t, finalPos, colorResult);
            }
            
            return finalPos;
        }

        void main() {
            // 1. Calculate Base Animation Position
            vec3 animatedPos = calculatePosition(position, time, currentTemplate, vColor);

            // 2. Mouse Repulsion Logic
            // Calculate distance between particle and mouse in world space
            float dist = distance(animatedPos, mousePosition);
            
            if (dist < 2.0) {
                vec3 repulseDir = normalize(animatedPos - mousePosition);
                float force = (2.0 - dist) * 0.3; // Strong repulsion
                animatedPos += repulseDir * force;
            }

            // 3. Final Transformations
            vec4 mvPosition = modelViewMatrix * vec4(animatedPos, 1.0);
            gl_Position = projectionMatrix * mvPosition;

            // 4. Size Attenuation
            gl_PointSize = size * globalScale * (500.0 / -mvPosition.z);
        }
    </script>

    <!-- FRAGMENT SHADER -->
    <script type="x-shader/x-fragment" id="fragmentshader">
        varying vec3 vColor;
        
        // Placeholder for texture uniform (technically unused in logic below, but required by prompt)
        uniform sampler2D pointTexture; 

        void main() {
            // Calculate distance from center of the point (0.0 to 0.5)
            // gl_PointCoord returns vec2(0..1, 0..1)
            vec2 coord = gl_PointCoord - vec2(0.5);
            float dist = length(coord);

            // Soft Circle Logic
            // discard pixels outside circle radius 0.5
            if (dist > 0.5) discard;

            // Smoothstep for glow effect (inner 0.0 to outer 0.5)
            float alpha = 1.0 - smoothstep(0.0, 0.5, dist);

            gl_FragColor = vec4(vColor, 1.0) * alpha;
        }
    </script>

    <!-- MAIN JAVASCRIPT -->
    <script>
        // --- 1. CONFIGURATION ---
        const PARTICLE_COUNT = 80000;
        const NUM_TEMPLATES = 5;
        const TEMPLATE_SWITCH_INTERVAL = 8.0; // Seconds
        const TEMPLATE_NAMES = [
            "Wavy Cloud", 
            "Breathing Sphere", 
            "Fireworks Burst", 
            "2D Heart Shape", 
            "Rotating Saturn Ring"
        ];

        // --- 2. SETUP ---
        const scene = new THREE.Scene();
        
        // Z = 5 Camera
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 5;

        // Renderer
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        // --- 3. PARTICLES ---
        const geometry = new THREE.BufferGeometry();
        const positions = [];
        const sizes = [];

        // Initialize particles
        for (let i = 0; i < PARTICLE_COUNT; i++) {
            // Random Cube: -2 to 2
            const x = (Math.random() * 4) - 2;
            const y = (Math.random() * 4) - 2;
            const z = (Math.random() * 4) - 2;

            positions.push(x, y, z);

            // Size: 0.05 to 0.2
            sizes.push(0.05 + Math.random() * 0.15);
        }

        geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
        geometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));

        // Uniforms
        const uniforms = {
            time: { value: 0.0 },
            globalScale: { value: 1.0 },
            mousePosition: { value: new THREE.Vector3(999, 999, 999) }, // Init off-screen
            currentTemplate: { value: 0.0 },
            pointTexture: { value: new THREE.Texture() } // Empty texture prevents 404
        };

        const material = new THREE.ShaderMaterial({
            uniforms: uniforms,
            vertexShader: document.getElementById('vertexshader').textContent,
            fragmentShader: document.getElementById('fragmentshader').textContent,
            blending: THREE.AdditiveBlending,
            depthTest: false,
            transparent: true
        });

        const particleSystem = new THREE.Points(geometry, material);
        scene.add(particleSystem);

        // --- 4. EVENT LISTENERS ---
        
        // Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Mouse Move (Map 2D screen to 3D world at Z approx -2)
        const mouse = new THREE.Vector2();
        const raycaster = new THREE.Raycaster();
        const interactionPlaneZ = -2;

        window.addEventListener('mousemove', (event) => {
            // Normalize mouse coordinates (-1 to 1)
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            // Unproject logic to find position at specific Z depth
            // 1. Create vector at mouse position on near plane
            let vec = new THREE.Vector3(mouse.x, mouse.y, 0.5);
            
            // 2. Unproject: converts from screen space to world space
            vec.unproject(camera);
            
            // 3. Calculate direction from camera to this unprojected point
            vec.sub(camera.position).normalize();
            
            // 4. Calculate distance scalar to hit plane Z = -2
            // formula: distance = (targetZ - cameraZ) / directionZ
            let distance = (interactionPlaneZ - camera.position.z) / vec.z;
            
            // 5. Final position
            let pos = new THREE.Vector3().copy(camera.position).add(vec.multiplyScalar(distance));
            
            uniforms.mousePosition.value.copy(pos);
        });

        // --- 5. ANIMATION LOOP ---
        const clock = new THREE.Clock();
        let templateTimer = 0;
        let currentTemplateIndex = 0;
        const modeLabel = document.getElementById('mode');

        function animate() {
            requestAnimationFrame(animate);

            const delta = clock.getDelta();
            const elapsedTime = clock.getElapsedTime();

            // Update Shader Time
            uniforms.time.value = elapsedTime;

            // Template Switching Logic
            templateTimer += delta;
            if (templateTimer >= TEMPLATE_SWITCH_INTERVAL) {
                templateTimer = 0;
                currentTemplateIndex = (currentTemplateIndex + 1) % NUM_TEMPLATES;
                uniforms.currentTemplate.value = parseFloat(currentTemplateIndex);
                
                // Update UI text
                modeLabel.innerText = TEMPLATE_NAMES[currentTemplateIndex];
            }

            renderer.render(scene, camera);
        }

        animate();
    </script>
</body>
</html>
