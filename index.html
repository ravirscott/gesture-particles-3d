<!DOCTYPE html>
<html>
<head>
    <title>Hand Gesture Particle System</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        /* CSS: Fullscreen setup */
        body { margin: 0; overflow: hidden; background-color: #000000; }
        canvas { display: block; }
        /* Video feed is hidden, only used by MediaPipe */
        #webcam-feed { position: absolute; top: 0; left: 0; z-index: 10; display: none; }
    </style>
</head>
<body>
    <video id="webcam-feed" autoplay></video>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils"></script>

    <script id="vertexshader" type="x-shader/x-vertex">
        uniform float time;
        uniform float globalScale;
        uniform float isPinching;
        uniform vec3 handPosition;
        
        attribute float size;
        attribute vec3 color;
        attribute float templateId;
        
        varying vec3 vColor;
        
        void main() {
            vColor = color;
            vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
            
            // World position for repulsion calculation
            vec3 worldPosition = (modelMatrix * vec4(position, 1.0)).xyz;
            float distanceToHand = length(worldPosition - handPosition);
            
            // Repulsion based on Pinching gesture
            if (isPinching > 0.5) {
                vec3 direction = normalize(worldPosition - handPosition);
                // Push nearby particles away
                mvPosition.xyz += direction * max(0.0, 0.5 - distanceToHand) * 5.0; 
            }

            // Simple movement/template logic
            if (templateId > 1.5 && templateId < 2.5) { 
                mvPosition.y += sin(time * 0.5) * 0.01; 
            }

            // Final size and screen position
            gl_PointSize = size * globalScale * (300.0 / -mvPosition.z);
            gl_Position = projectionMatrix * mvPosition;
        }
    </script>

    <script id="fragmentshader" type="x-shader/x-fragment">
        uniform sampler2D pointTexture;
        uniform float currentColorIndex; 

        varying vec3 vColor;

        void main() {
            // Dynamic Color Cycling
            vec4 color1 = vec4(1.0, 0.5, 0.0, 1.0); // Orange
            vec4 color2 = vec4(0.0, 0.5, 1.0, 1.0); // Blue
            vec4 blendedColor = mix(color1, color2, currentColorIndex);
            
            // Texture mapping and transparency
            vec4 textureColor = texture2D(pointTexture, gl_PointCoord);

            // Blending the texture (if loaded) with the dynamic color
            gl_FragColor = blendedColor * textureColor; 
            
            // Create a circular shape with fading edges
            float r = dot(gl_PointCoord - vec2(0.5), gl_PointCoord - vec2(0.5));
            float alpha = 1.0 - smoothstep(0.0, 0.25, r);
            gl_FragColor.a *= alpha;
        }
    </script>

    <script>
        // --- Global Variables ---
        let handLandmarks = null;
        let particles;
        const PARTICLE_COUNT = 50000;
        
        // --- MediaPipe Hand Tracking Setup ---
        const videoElement = document.getElementById('webcam-feed');
        
        // FIX: Added locateFile for correct model loading
        const hands = new Hands({
            locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
            }
        });

        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.7,
            minTrackingConfidence: 0.7
        });

        hands.onResults((results) => {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                handLandmarks = results.multiHandLandmarks[0];
            } else {
                handLandmarks = null;
            }
        });

        const cameraFeed = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({ image: videoElement });
            },
            width: 1280,
            height: 720
        });
        cameraFeed.start();

        // Gesture Detection: Pinch (Thumb tip 4 and Index tip 8)
        function isPinching(landmarks) {
            if (!landmarks) return false;
            const thumbTip = landmarks[4];
            const indexTip = landmarks[8];
            const distance = Math.sqrt(
                Math.pow(thumbTip.x - indexTip.x, 2) +
                Math.pow(thumbTip.y - indexTip.y, 2)
            );
            return distance < 0.05; 
        }
        
        // --- Three.js Setup ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
        camera.position.z = 5;

        // Handle window resizing
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        function createParticles() {
            const particleGeometry = new THREE.BufferGeometry();
            const positions = new Float32Array(PARTICLE_COUNT * 3);
            const sizes = new Float32Array(PARTICLE_COUNT);
            const templateIds = new Float32Array(PARTICLE_COUNT);

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                // FIX: Particles are forced to be close to the camera (Z=1 to Z=4)
                positions[i * 3 + 0] = (Math.random() - 0.5) * 2; // X position: -1 to 1
                positions[i * 3 + 1] = (Math.random() - 0.5) * 2; // Y position: -1 to 1
                positions[i * 3 + 2] = Math.random() * 3 + 1;     // Z position: 1 to 4 (Near the camera at Z=5)
                
                sizes[i] = Math.random() * 0.1 + 0.05;
                templateIds[i] = Math.floor(Math.random() * 3); 
            }

            particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            particleGeometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            particleGeometry.setAttribute('templateId', new THREE.BufferAttribute(templateIds, 1));

            // Load Texture (Fallback included)
            let particleTexture;
            try {
                particleTexture = new THREE.TextureLoader().load('spark.png');
            } catch (e) {
                particleTexture = new THREE.Texture(); 
            }
            
            const particleMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    pointTexture: { value: particleTexture }, 
                    time: { value: 0.0 },
                    globalScale: { value: 1.0 },
                    isPinching: { value: 0.0 },
                    handPosition: { value: new THREE.Vector3(0, 0, 0) },
                    currentColorIndex: { value: 0.0 }
                },
                vertexShader: document.getElementById('vertexshader').textContent,
                fragmentShader: document.getElementById('fragmentshader').textContent,
                blending: THREE.AdditiveBlending,
                depthTest: false,
                transparent: true
            });

            particles = new THREE.Points(particleGeometry, particleMaterial);
            scene.add(particles);
        }

        createParticles();

        // --- Animation Loop ---
        let time = 0;
        let currentColorIndex = 0;

        function animate() {
            requestAnimationFrame(animate);

            time += 0.01;
            particles.material.uniforms.time.value = time;
            
            if (handLandmarks) {
                // 1. Pinch Detection
                const pinching = isPinching(handLandmarks);
                particles.material.uniforms.isPinching.value = pinching ? 1.0 : 0.0;
                
                // 2. Control Particle Size (Expansion/Contraction) using Hand Depth (Z)
                const avgZ = handLandmarks[9].z;
                const globalScale = THREE.MathUtils.mapLinear(avgZ, 0.1, 0.8, 2.0, 0.5);
                particles.material.uniforms.globalScale.value = globalScale;
                
                // 3. Hand Position for Repulsion/Attraction
                const mappedX = THREE.MathUtils.mapLinear(handLandmarks[9].x, 0, 1, -5, 5);
                const mappedY = THREE.MathUtils.mapLinear(handLandmarks[9].y, 0, 1, 5, -5); 
                particles.material.uniforms.handPosition.value.set(mappedX, mappedY, 0); 
                
                // 4. Color Cycling on Gesture
                const colorSpeed = pinching ? 0.05 : 0.005;
                currentColorIndex = (currentColorIndex + colorSpeed) % 1; 
                particles.material.uniforms.currentColorIndex.value = currentColorIndex;

            } else {
                // Default settings when no hand is detected
                particles.material.uniforms.isPinching.value = 0.0;
                particles.material.uniforms.globalScale.value = 1.0;
            }

            renderer.render(scene, camera);
        }

        animate();
    </script>
</body>
</html>
