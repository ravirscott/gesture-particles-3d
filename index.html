<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Advanced Three.js Shader Particle System</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <style>
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #000;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>

<!-- ===================== VERTEX SHADER ===================== -->
<script id="vertexShader" type="x-shader/x-vertex">
precision highp float;

attribute float size;

uniform float time;
uniform float globalScale;
uniform float currentTemplate;
uniform vec3 mousePosition;

varying vec3 vColor;

vec3 calculatePosition(vec3 p, float t, float templateID) {

  // ---------- TEMPLATE 0 : WAVY CLOUD ----------
  if (templateID < 0.5) {
    float waveX = sin(p.y * 2.0 + t) * 0.5;
    float waveY = cos(p.x * 2.0 + t * 1.2) * 0.5;
    vColor = vec3(0.0, 0.5 + 0.5 * sin(t * 0.8), 1.0);
    return vec3(p.x + waveX, p.y + waveY, p.z);
  }

  // ---------- TEMPLATE 1 : BREATHING SPHERE ----------
  if (templateID < 1.5) {
    vec3 dir = normalize(p);
    float pulse = 1.0 + 0.3 * sin(t * 1.5);
    vColor = vec3(1.0, 0.2 + 0.5 * sin(t * 0.5), 0.0);
    return dir * pulse * 2.0;
  }

  // ---------- TEMPLATE 2 : FIREWORKS BURST ----------
  if (templateID < 2.5) {
    float phase = fract(t * 0.1);
    vec3 dir = normalize(p);
    float strength = smoothstep(0.0, 1.0, phase) * 6.0;
    vColor = fract(p * 3.0 + phase);
    return dir * strength;
  }

  // ---------- TEMPLATE 3 : HEART SHAPE ----------
  if (templateID < 3.5) {
    float th = p.z * 6.28318;
    float x = 16.0 * pow(sin(th), 3.0);
    float y = 13.0 * cos(th)
            - 5.0 * cos(2.0 * th)
            - 2.0 * cos(3.0 * th)
            - cos(4.0 * th);
    vColor = vec3(1.0, 0.2, 0.6);
    return vec3(x, y, 0.0) * 0.08;
  }

  // ---------- TEMPLATE 4 : SATURN RING ----------
  float theta = p.x * 3.14159;
  float phi = p.y * 6.28318;
  float r = 2.5 + p.z * 0.5;

  float cx = cos(phi) * r;
  float cz = sin(phi) * r;

  float rot = t * 0.05;
  float rx = cx * cos(rot) - cz * sin(rot);
  float rz = cx * sin(rot) + cz * cos(rot);

  vColor = vec3(0.5, 0.8, 1.0);
  return vec3(rx, sin(theta) * 0.2, rz);
}

void main() {
  vec3 worldPosition = calculatePosition(position, time, currentTemplate);

  // ---------- MOUSE REPULSION ----------
  float dist = distance(worldPosition, mousePosition);
  if (dist < 2.0) {
    vec3 repelDir = normalize(worldPosition - mousePosition);
    worldPosition += repelDir * (2.0 - dist) * 0.3;
  }

  vec4 mvPosition = modelViewMatrix * vec4(worldPosition, 1.0);
  gl_Position = projectionMatrix * mvPosition;

  gl_PointSize = size * globalScale * (500.0 / -mvPosition.z);
}
</script>

<!-- ===================== FRAGMENT SHADER ===================== -->
<script id="fragmentShader" type="x-shader/x-fragment">
precision highp float;

varying vec3 vColor;

void main() {
  float d = length(gl_PointCoord - vec2(0.5));
  float alpha = smoothstep(0.5, 0.0, d);
  gl_FragColor = vec4(vColor, 1.0) * alpha;
}
</script>

<!-- ===================== THREE.JS APP ===================== -->
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
<script>
/* ===================== CONSTANTS ===================== */
const PARTICLE_COUNT = 80000;
const NUM_TEMPLATES = 5;
const templateSwitchInterval = 8.0;

/* ===================== SCENE SETUP ===================== */
const scene = new THREE.Scene();

const camera = new THREE.PerspectiveCamera(
  60,
  window.innerWidth / window.innerHeight,
  0.1,
  100
);
camera.position.z = 5;

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);
renderer.setClearColor(0x000000, 1);
document.body.appendChild(renderer.domElement);

/* ===================== GEOMETRY ===================== */
const geometry = new THREE.BufferGeometry();

const positions = new Float32Array(PARTICLE_COUNT * 3);
const sizes = new Float32Array(PARTICLE_COUNT);

for (let i = 0; i < PARTICLE_COUNT; i++) {
  positions[i * 3 + 0] = (Math.random() * 4 - 2);
  positions[i * 3 + 1] = (Math.random() * 4 - 2);
  positions[i * 3 + 2] = (Math.random() * 4 - 2);
  sizes[i] = Math.random() * 0.15 + 0.05;
}

geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

/* ===================== UNIFORMS ===================== */
const uniforms = {
  time: { value: 0 },
  globalScale: { value: 1.0 },
  mousePosition: { value: new THREE.Vector3() },
  currentTemplate: { value: 0.0 },
  pointTexture: { value: new THREE.Texture() }
};

/* ===================== MATERIAL ===================== */
const material = new THREE.ShaderMaterial({
  uniforms,
  vertexShader: document.getElementById('vertexShader').textContent,
  fragmentShader: document.getElementById('fragmentShader').textContent,
  transparent: true,
  blending: THREE.AdditiveBlending,
  depthWrite: false
});

const points = new THREE.Points(geometry, material);
scene.add(points);

/* ===================== MOUSE HANDLING ===================== */
const mouse = new THREE.Vector2();
const raycaster = new THREE.Raycaster();
const planeZ = new THREE.Plane(new THREE.Vector3(0, 0, 1), 2);

window.addEventListener('mousemove', (e) => {
  mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
  mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
  raycaster.setFromCamera(mouse, camera);
  const hit = new THREE.Vector3();
  raycaster.ray.intersectPlane(planeZ, hit);
  uniforms.mousePosition.value.copy(hit);
});

/* ===================== RESIZE ===================== */
window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

/* ===================== ANIMATION LOOP ===================== */
let lastTime = performance.now();
let templateTimer = 0;
let currentTemplate = 0;

function animate(now) {
  requestAnimationFrame(animate);

  const delta = (now - lastTime) * 0.001;
  lastTime = now;

  uniforms.time.value += delta;
  templateTimer += delta;

  if (templateTimer > templateSwitchInterval) {
    templateTimer = 0;
    currentTemplate = (currentTemplate + 1) % NUM_TEMPLATES;
    uniforms.currentTemplate.value = currentTemplate;
  }

  renderer.render(scene, camera);
}

animate(performance.now());
</script>

</body>
</html>
